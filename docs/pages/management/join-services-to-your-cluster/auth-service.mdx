---
title: Register Services via the Auth Service
description: How to register services directly with the Teleport Auth Service via a join token
---

This guide will show you how to join a Teleport process to your cluster by
presenting a **join token** directly to the Teleport Auth Service, without
connecting via the Proxy Service.

In this approach, you declare your intention to register a new Teleport process,
and Teleport generates a secure token for the service. When the service starts,
it presents the token, indicating to your Teleport cluster that it is
trustworthy.

<Admonition type="warning" title="Before following this guide">

In most cases, you should be able to register Teleport services via the Proxy
Service using a join token or another method. See our overview of [Registering
Services](../registering-services.mdx) for all available methods.

Only connect services directly to the Auth Service if no other methods are
suitable, as we recommend exposing the Auth Service to as few sources of ingress
traffic as possible.

</Admonition>

## Prerequisites

(!docs/pages/includes/edition-prereqs-tabs.mdx!)

- A Linux server that you will use to host your Teleport service. 

  In this guide, we will show you how to register a Teleport SSH Service
  instance. This approach applies to new Proxy Service instances as well as the
  Kubernetes Service, Database Service, and other Teleport services for
  accessing resources in your infrastructure.

(!docs/pages/includes/tctl.mdx!)

## Step 1/3. Install Teleport

Install Teleport on the host where you will run your Teleport service.

(!docs/pages/includes/install-linux.mdx!)

## Step 2/3. Join your Teleport process to the cluster

In this section, we will join your Teleport process to your cluster by:

- Obtaining a CA pin to establish trust with the Auth Service
- Obtaining a join token
- Running your Teleport service with the join token

### Obtain a CA pin

In a zero-trust environment, you must assume that an attacker can hijack the IP
address of the Auth Service.

To prevent this from happening, you need to supply your new service with
information about the Auth Service. This technique is called **CA pinning**. It
works by asking the Auth Service to produce a CA pin, a hash value of the SPKI
header in a certificate. This way, an attacker cannot easily forge a matching
private key.

If a CA pin is not provided, the Teleport service will join a cluster but it
will print a warning message.

<Notice type="warning">

The CA pin becomes invalid if a Teleport administrator performs the CA rotation
by executing [`tctl auth rotate`](../../reference/cli.mdx#tctl-auth-rotate).
    
</Notice>

On you local machine, retrieve the CA pin of the Auth Service <ScopedBlock
scope="cloud"> by running the following command on your local
machine</ScopedBlock>:

```code
$ export CA_PIN=$(tctl status | awk '/CA pin/{print $3}')
```

### Generate a token

Teleport only allows access to resources that have joined the cluster.

Once a service joins, it receives a host certificate signed by the cluster's
Auth Service. To receive a host certificate upon joining a cluster, a new
Teleport host must present an **join token**.

A join token also defines which role a new host can assume within a cluster:

- `proxy`
- `node`
- `auth`
- `app`
- `db`
- `kube`
- `windowsdesktop`

Administrators can generate tokens as they are needed. A token can be used
multiple times until its time to live (TTL) expires.

On your local machine, use the `tctl` tool to generate a new token. In the
following example, a new token is created with a TTL of five minutes:

```code
$ export INVITE_TOKEN=$(tctl tokens add --ttl=5m --roles=node | grep "join token:" | grep -Eo "[0-9a-z]{32}")
$ echo $INVITE_TOKEN
# (=presets.tokens.first=)

# You can also list all generated non-expired tokens:
$ tctl tokens ls
# Token                            Type            Expiry Time
# ------------------------         -----------     ---------------
# (=presets.tokens.first=)         service            25 Sep 18 00:21 UTC
```

<Details title="Provide your own token value">

Rather than automatically generating a token, you can create one with a known
value by using the `--token` flag:

```code
$ tctl nodes add --ttl=5m --roles=node,proxy --token=secret-value
# The join token: secret-value
```

The value of `--token` should be cryptographically secure. For example, you can
create an SHA256 hash to reduce the risk that a malicious actor will produce
a token with the same value as yours:

```code
$ head -n 1 /dev/random | sha256sum
```

</Details>

<Details scope={["oss","enterprise"]} title="An insecure alternative: static tokens" scopeOnly={false}>

<Notice type="danger">
Use short-lived tokens instead of long-lived static tokens.
Static tokens are easier to steal, guess, and leak.
</Notice>

Static tokens are defined ahead of time by an administrator and stored in the
Auth Service's config file:

```yaml
# Config section in `/etc/teleport.yaml` file for the auth server
auth_service:
    enabled: true
    tokens:
    # This static token allows new hosts to join the cluster as "proxy" or "node"
    - "proxy,node:secret-token-value"
    # A token can also be stored in a file. In this example the token for adding
    # new auth servers are stored in /path/to/tokenfile
    - "auth:/path/to/tokenfile"
```
</Details>

### Start your service with the join token and CA pin

Execute the following commands on the host where you will run your service so you
can use the `CA_PIN` and `INVITE_TOKEN` variables to start Teleport.

```code
$ export CA_PIN=<Var name="ca-pin" />
$ export INVITE_TOKEN=<Var name="invite-token" />
```

Still on the host where you will run your service, assign the address of your
Auth Service to an environment variable, including the domain name (or IP
address) and port:

```code
$ export ADDR=teleport.example.com:3025
```

Execute the following command on your service to add it to a cluster:

```code
$ sudo teleport start \
   --roles=node \
   --token=${INVITE_TOKEN?} \
   --ca-pin=${CA_PIN?} \
   --auth-server=${ADDR?}
```

As new services come online, they start sending ping requests every few seconds to
the Auth Service. This allows users to explore cluster membership and size.

Run the following command on your local machine to see all of the Teleport services
in your cluster:

```code
$ tctl nodes ls

service Name     service ID                                  Address            Labels
---------     -------                                  -------            ------
turing        d52527f9-b260-41d0-bb5a-e23b0cfe0f8f     10.1.0.5:3022      distro:ubuntu
dijkstra      c9s93fd9-3333-91d3-9999-c9s93fd98f43     10.1.0.6:3022      distro:debian
```

## Step 3/3. Revoke an invitation

Tokens used for joining services to a cluster can be revoked before they are used.

Run the following command on your local machine to create a token for a new
Proxy Service:

```code
$ tctl nodes add --ttl=5m --roles=proxy 
# The join token: (=presets.tokens.first=).
# This token will expire in 5 minutes.
# 
# Run this on the new node to join the cluster:
# 
# > teleport start \
#    --roles=proxy \
#    --token=(=presets.tokens.first=) \
#    --ca-pin=(=presets.ca_pin=) \
#    --auth-server=123.123.123.123:443
# 
# Please note:
# 
#   - This invitation token will expire in 5 minutes
#   - 123.123.123.123 must be reachable from the new node
```

Next, run the following command to see a list of outstanding tokens:

```
$ tctl tokens ls

# Token                                Role       Expiry Time (UTC)
# -----                                ----       -----------------
# (=presets.tokens.first=)     Proxy      never
# (=presets.tokens.second=)    Service      17 May 16 03:51 UTC
# (=presets.tokens.third=)     Signup     17 May 16 04:24 UTC
```

<Admonition type="tip" title="Signup tokens">

The output of `tctl tokens ls` includes tokens used for adding users alongside
tokens used for adding services to your cluster.

</Admonition>

In this example, the first token has a `never` expiry date because it is a
static token configured via a config file.

The token with the `service` role was generated to invite a new service to this
cluster. And the third token was generated to invite a new user to sign up.

Tokens created via `tctl` can be deleted (revoked) via the `tctl tokens del`
command. Run the following command to delete a token:

```code
$ tctl tokens del (=presets.tokens.first=)
# Token (=presets.tokens.first=) has been deleted
```
